#************************************************************* ## ECE 344L - Microprocessors - Spring 2015## Name: Matthew James Greci##     Laboratory Number: 1   Due Date: February 3, 2015### Lab Group:### #*************************************************************** ## This program solves Problem 5. Compute the dot product of two # vectors. Vectors are defined as arrays and the values are 
# generated by the set of rules as described in the lab assignment. 
# The final dot product answer is then stored in memory.
## #***************************************************************
#include <p32xxxx.h>

.global main

.data

.text 

.set noreorder

.ent main

VECA: 
	 .long 0xA0000300
VECB:
	 .long 0xA0000450
main: 
	#Clear registers
	and t0,t0,zero
	and t1,t1,zero
	and t2,t2,zero
	and s0,s0,zero
	and s1,s1,zero
	and s2,s2,zero
	nop
	#VECA Loop
	lw s0, VECA  #Starting address
	li s1, 54    #Value to store
	li s2, 80    #Loop counter (results in 80 loops)
	nop
	loopVECA:
		sw   s1, 0(s0)     #Store the word into address of s0
		addi s1, 13        #Increment value by 13
		addi s0, 0x04      #Increment s0 address by 4 bytes (32 bits) 
		addi s2, s2, -1    #Decrement loop counter by 1 
		bgtz s2, loopVECA  #Branch if s2 > 0
		nop
	#VECB Loop
	lw s0, VECB  #Starting address
	li s1, 157   #Value to store
	li s2, 80    #Loop counter (results in 80 loops)
	nop
	loopVECB:
		sw   s1, 0(s0)     #Store the word into address of s0
		addi s1, 18        #Increment value by 18
		addi s0, 0x04      #Increment s0 address by 4 bytes (32 bits)
		addi s2, s2, -1    #Decrement loop counter by 1
		bgtz s2, loopVECB  #Branch if s2 > 0
		nop
	#Dot Product Loop	
	lw s0, VECA   #Starting VECA address
	lw s1, VECB   #Starting VECB address
	li s2, 80     #Loop counter (results in 80 loops)
	li t2, 0      #Store total summation (final answer)
	nop
	dot_product:
		nop
		lw t0, 0x00(s0)       #Load VECA value into t0
		lw t1, 0x00(s1)       #Load VECB value into t1
		mul t3, t0, t1        #Multiply (t0 and t1) and place in t0
		add  t2, t2,t3        #Add result (t0) to t2
		addi s0, 0x04         #Increment s0 by 4 bytes (32 bits, next address)
		addi s1, 0x04         #Increment s1 by 4 bytes (32 bits, next address)
		addi s2, s2,-1	      #Decrement loop counter by 1
		bgtz s2, dot_product  #Branch if s0 > 0
		nop
		#final answer at 0xA00002F0
		sw t2, 0xA00002F0
		nop
	loop:
		b loop
		nop
		nop
.end main 
